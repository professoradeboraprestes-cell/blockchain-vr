<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>How Blockchain Works - VR</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r158/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r158/examples/js/controls/DeviceOrientationControls.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r158/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r158/examples/js/geometries/TextGeometry.js"></script>
<style>
  html, body {margin:0;overflow:hidden;background:#050514;height:100%;width:100%;}
  canvas {display:block;}
  #msg {position:fixed;top:10px;left:10px;color:cyan;font-family:sans-serif;}
</style>
</head>
<body>
<div id="msg">Move your phone or headset to look around</div>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050514);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 0);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.DeviceOrientationControls(camera);
const light = new THREE.PointLight(0x00ffff, 2, 50);
light.position.set(0, 5, 5);
scene.add(light);
scene.add(new THREE.AmbientLight(0x6666ff, 0.6));

const loader = new THREE.FontLoader();
let blocks = new THREE.Group();
scene.add(blocks);

const stages = [
 {n:1, text:"Someone requests a transaction."},
 {n:2, text:"The transaction is broadcast to a peer-to-peer network of computers (nodes)."},
 {n:3, text:"The network validates the transaction and the user's status using algorithms."},
 {n:4, text:"A verified transaction may involve cryptocurrency, contracts, or records."},
 {n:5, text:"Once verified, the transaction is combined with others to create a new block."},
 {n:6, text:"The new block is added to the existing blockchain, permanent and unalterable."},
 {n:7, text:"The transaction is completed."}
];

loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
  const radius = 6;
  stages.forEach((s, i) => {
    const angle = (i / stages.length) * Math.PI * 2;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;

    const cubeMat = new THREE.MeshStandardMaterial({color: 0x00ffff, emissive: 0x0088ff, emissiveIntensity: 0.6});
    const cube = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), cubeMat);
    cube.position.set(x, 1.6, z);
    cube.lookAt(0, 1.6, 0);
    blocks.add(cube);

    const numGeo = new THREE.TextGeometry(s.n.toString(), {font: font, size: 0.5, height: 0.05});
    const numMat = new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0x00ffff});
    const num = new THREE.Mesh(numGeo, numMat);
    num.position.set(x - 0.25, 2.5, z);
    num.lookAt(0, 2.5, 0);
    scene.add(num);

    const textGeo = new THREE.TextGeometry(s.text, {font: font, size: 0.18, height: 0.02});
    const textMat = new THREE.MeshStandardMaterial({color: 0xffffff});
    const txt = new THREE.Mesh(textGeo, textMat);
    txt.position.set(x - 2.5, 0.8, z);
    txt.lookAt(0, 1.6, 0);
    txt.visible = false;
    cube.userData.textMesh = txt;
    scene.add(txt);
  });

  makeArrow("← Look Left", new THREE.Vector3(-3, 0.5, -3));
  makeArrow("→ Look Right", new THREE.Vector3(3, 0.5, -3));
  makeArrow("↑ Look Up", new THREE.Vector3(0, 3, -3));
  makeArrow("↓ Look Down", new THREE.Vector3(0, -2, -3));
});

function makeArrow(text, pos) {
  loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
    const geo = new THREE.TextGeometry(text, {font: font, size: 0.25, height: 0.02});
    const mat = new THREE.MeshStandardMaterial({color: 0x00ffff, emissive: 0x0077ff});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
  });
}

let raycaster = new THREE.Raycaster();
function checkFocus() {
  raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
  const intersects = raycaster.intersectObjects(blocks.children);
  blocks.children.forEach(b => {
    if (b.userData.textMesh) b.userData.textMesh.visible = false;
  });
  if (intersects.length > 0) {
    const obj = intersects[0].object;
    if (obj.userData.textMesh) obj.userData.textMesh.visible = true;
  }
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  checkFocus();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
